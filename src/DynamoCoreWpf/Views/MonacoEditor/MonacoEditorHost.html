<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Monaco Editor</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        html, body {
            width: 100%;
            height: 100%;
            overflow: hidden;
            background-color: #252526;
        }
        
        #editor-container {
            width: 100%;
            height: 100%;
        }
        
        /* Custom scrollbar styling to match VS Code */
        ::-webkit-scrollbar {
            width: 10px;
            height: 10px;
        }
        
        ::-webkit-scrollbar-track {
            background: #1e1e1e;
        }
        
        ::-webkit-scrollbar-thumb {
            background: #424242;
            border-radius: 5px;
        }
        
        ::-webkit-scrollbar-thumb:hover {
            background: #4f4f4f;
        }
    </style>
</head>
<body>
    <div id="editor-container"></div>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/monaco-editor/0.45.0/min/vs/loader.min.js"></script>
    <script>
        // Monaco Editor instance
        let editor = null;
        let currentLanguage = 'python';
        let isInitialized = false;
        
        // Configure Monaco loader
        require.config({ 
            paths: { 
                'vs': 'https://cdnjs.cloudflare.com/ajax/libs/monaco-editor/0.45.0/min/vs' 
            }
        });
        
        // Language mapping for Dynamo node types
        const languageMap = {
            'python': 'python',
            'csharp': 'csharp',
            'designscript': 'javascript', // DesignScript syntax similar to JS
            'codeblock': 'javascript'     // Code blocks use DesignScript
        };
        
        // Initialize Monaco Editor
        require(['vs/editor/editor.main'], function() {
            // Register DesignScript as a custom language (based on JavaScript)
            monaco.languages.register({ id: 'designscript' });
            
            // Define DesignScript tokenization (simplified version)
            monaco.languages.setMonarchTokensProvider('designscript', {
                keywords: [
                    'def', 'return', 'if', 'elseif', 'else', 'for', 'while',
                    'true', 'false', 'null', 'Imperative', 'Associative'
                ],
                typeKeywords: [
                    'var', 'int', 'double', 'bool', 'string'
                ],
                operators: [
                    '=', '>', '<', '!', '~', '?', ':', '==', '<=', '>=', '!=',
                    '&&', '||', '++', '--', '+', '-', '*', '/', '&', '|', '^', '%',
                    '<<', '>>', '>>>', '+=', '-=', '*=', '/=', '&=', '|=', '^=',
                    '%=', '<<=', '>>=', '>>>='
                ],
                symbols: /[=><!~?:&|+\-*\/\^%]+/,
                tokenizer: {
                    root: [
                        [/[a-z_$][\w$]*/, { 
                            cases: { 
                                '@typeKeywords': 'keyword',
                                '@keywords': 'keyword',
                                '@default': 'identifier' 
                            } 
                        }],
                        [/[A-Z][\w\$]*/, 'type.identifier'],
                        { include: '@whitespace' },
                        [/[{}()\[\]]/, '@brackets'],
                        [/[<>](?!@symbols)/, '@brackets'],
                        [/@symbols/, { 
                            cases: { 
                                '@operators': 'operator',
                                '@default': '' 
                            } 
                        }],
                        [/\d*\.\d+([eE][\-+]?\d+)?/, 'number.float'],
                        [/\d+/, 'number'],
                        [/[;,.]/, 'delimiter'],
                        [/"([^"\\]|\\.)*$/, 'string.invalid'],
                        [/"/, { token: 'string.quote', bracket: '@open', next: '@string' }],
                    ],
                    string: [
                        [/[^\\"]+/, 'string'],
                        [/\\./, 'string.escape'],
                        [/"/, { token: 'string.quote', bracket: '@close', next: '@pop' }]
                    ],
                    whitespace: [
                        [/[ \t\r\n]+/, 'white'],
                        [/\/\*/, 'comment', '@comment'],
                        [/\/\/.*$/, 'comment'],
                    ],
                    comment: [
                        [/[^\/*]+/, 'comment'],
                        [/\/\*/, 'comment', '@push'],
                        [/\*\//, 'comment', '@pop'],
                        [/[\/*]/, 'comment']
                    ],
                }
            });
            
            // Create the editor
            editor = monaco.editor.create(document.getElementById('editor-container'), {
                value: '',
                language: currentLanguage,
                theme: 'vs-dark',
                automaticLayout: true,
                minimap: { 
                    enabled: true,
                    side: 'right',
                    showSlider: 'always',
                    renderCharacters: true,
                    maxColumn: 250
                },
                scrollBeyondLastLine: false,
                fontSize: 13,
                fontFamily: "'Source Code Pro', 'Consolas', 'Courier New', monospace",
                lineNumbers: 'on',
                renderWhitespace: 'selection',
                tabSize: 4,
                insertSpaces: true,
                wordWrap: 'off',
                folding: true,
                bracketPairColorization: { enabled: true },
                suggest: {
                    showMethods: true,
                    showFunctions: true,
                    showConstructors: true,
                    showFields: true,
                    showVariables: true,
                    showClasses: true,
                    showStructs: true,
                    showInterfaces: true,
                    showModules: true,
                    showProperties: true,
                    showEvents: true,
                    showOperators: true,
                    showUnits: true,
                    showValues: true,
                    showConstants: true,
                    showEnums: true,
                    showEnumMembers: true,
                    showKeywords: true,
                    showWords: true,
                    showColors: true,
                    showFiles: true,
                    showReferences: true,
                    showFolders: true,
                    showTypeParameters: true,
                    showSnippets: true
                },
                quickSuggestions: {
                    other: true,
                    comments: false,
                    strings: false
                },
                quickSuggestionsDelay: 10,
                suggestOnTriggerCharacters: true,
                acceptSuggestionOnCommitCharacter: true,
                acceptSuggestionOnEnter: 'on',
                tabCompletion: 'off',
                wordBasedSuggestions: 'matchingDocuments',
                parameterHints: { 
                    enabled: true,
                    cycle: false
                },
                formatOnPaste: true,
                formatOnType: true,
                hover: {
                    enabled: true,
                    delay: 300
                }
            });
            
            // Listen for content changes
            editor.onDidChangeModelContent(function(e) {
                if (window.chrome && window.chrome.webview) {
                    window.chrome.webview.postMessage({
                        type: 'contentChanged',
                        content: editor.getValue()
                    });
                }
            });
            
            // Listen for cursor position changes
            editor.onDidChangeCursorPosition(function(e) {
                if (window.chrome && window.chrome.webview) {
                    window.chrome.webview.postMessage({
                        type: 'cursorChanged',
                        line: e.position.lineNumber,
                        column: e.position.column
                    });
                }
            });
            
            // Listen for focus events
            editor.onDidFocusEditorText(function() {
                if (window.chrome && window.chrome.webview) {
                    window.chrome.webview.postMessage({
                        type: 'editorFocused'
                    });
                }
            });
            
            editor.onDidBlurEditorText(function() {
                if (window.chrome && window.chrome.webview) {
                    window.chrome.webview.postMessage({
                        type: 'editorBlurred'
                    });
                }
            });
            
            // Store pending requests (global, not language-specific)
            const pendingCompletions = {};
            const pendingHovers = {};
            const pendingSignatures = {};
            
            // Global handlers for responses (following Monaco standard pattern)
            window.handleCompletionResponse = function(rid, completions, incomplete) {
                console.log('handleCompletionResponse called:', { rid, completionsCount: completions?.length || 0, incomplete });
                if (pendingCompletions[rid]) {
                    const { resolve, range } = pendingCompletions[rid];
                    delete pendingCompletions[rid];
                    
                    // Convert to Monaco completion items (standard format)
                    const suggestions = (completions || []).map(function(c) {
                        // Handle both camelCase (from JSON) and PascalCase property names
                        const label = c.label || c.Label || c.text || c.Text || '';
                        const kindStr = c.kind || c.Kind || 'Text';
                        const insertText = c.insertText || c.InsertText || c.text || c.Text || label;
                        const detail = c.detail || c.Detail || '';
                        const documentation = c.documentation || c.Documentation || c.description || c.Description || '';
                        const sortText = c.sortText || c.SortText || label;
                        const filterText = c.filterText || c.FilterText || label;
                        
                        // Map string kind to Monaco CompletionItemKind
                        let kind = monaco.languages.CompletionItemKind.Text;
                        if (typeof kindStr === 'string') {
                            // Try to find the matching enum value
                            const kindUpper = kindStr.toUpperCase();
                            if (monaco.languages.CompletionItemKind[kindStr]) {
                                kind = monaco.languages.CompletionItemKind[kindStr];
                            } else if (monaco.languages.CompletionItemKind[kindUpper]) {
                                kind = monaco.languages.CompletionItemKind[kindUpper];
                            } else {
                                // Try common mappings
                                const kindMap = {
                                    'CLASS': monaco.languages.CompletionItemKind.Class,
                                    'METHOD': monaco.languages.CompletionItemKind.Method,
                                    'FUNCTION': monaco.languages.CompletionItemKind.Function,
                                    'PROPERTY': monaco.languages.CompletionItemKind.Property,
                                    'FIELD': monaco.languages.CompletionItemKind.Field,
                                    'VARIABLE': monaco.languages.CompletionItemKind.Variable,
                                    'MODULE': monaco.languages.CompletionItemKind.Module,
                                    'ENUM': monaco.languages.CompletionItemKind.Enum
                                };
                                kind = kindMap[kindUpper] || monaco.languages.CompletionItemKind.Text;
                            }
                        }
                        
                        return {
                            label: label,
                            kind: kind,
                            insertText: insertText,
                            detail: detail,
                            documentation: {
                                value: documentation,
                                isTrusted: true
                            },
                            range: range,
                            sortText: sortText,
                            filterText: filterText,
                            insertTextRules: monaco.languages.CompletionItemInsertTextRule.InsertAsSnippet
                        };
                    });
                    
                    console.log('Resolving with suggestions:', suggestions.length);
                    // Return in standard Monaco format with optional incomplete flag
                    // incomplete: true indicates more results might be available
                    resolve({ 
                        suggestions: suggestions,
                        incomplete: incomplete === true
                    });
                } else {
                    console.log('No pending completion found for requestId:', rid);
                }
            };
            
            // Register IntelliSense providers for Python
            // Always register for Python language (Monaco's built-in Python support)
            console.log('Registering IntelliSense providers for Python, currentLanguage:', currentLanguage);
            
            // Register providers for Python language
            (function() {
                
                window.handleHoverResponse = function(rid, hoverInfo) {
                    if (pendingHovers[rid]) {
                        const { resolve } = pendingHovers[rid];
                        delete pendingHovers[rid];
                        resolve(hoverInfo);
                    }
                };
                
                window.handleSignatureResponse = function(rid, signatureInfo) {
                    if (pendingSignatures[rid]) {
                        const { resolve } = pendingSignatures[rid];
                        delete pendingSignatures[rid];
                        resolve(signatureInfo);
                    }
                };
                
                // 1. Completion Provider - Following Monaco Editor standard pattern
                // Register with high priority to override built-in Python support
                monaco.languages.registerCompletionItemProvider('python', {
                    // Standard trigger characters for Python IntelliSense
                    triggerCharacters: ['.', '(', '[', ' '],
                    provideCompletionItems: function(model, position, context) {
                        console.log('Monaco completion provider called:', {
                            language: model.getLanguageId(),
                            line: position.lineNumber,
                            column: position.column,
                            triggerKind: context.triggerKind,
                            triggerCharacter: context.triggerCharacter
                        });
                        
                        return new Promise(function(resolve, reject) {
                            // Handle different trigger kinds (standard Monaco pattern)
                            // context.triggerKind can be:
                            // - monaco.languages.CompletionTriggerKind.Invoke (Ctrl+Space)
                            // - monaco.languages.CompletionTriggerKind.TriggerCharacter (typed trigger char)
                            // - monaco.languages.CompletionTriggerKind.TriggerForIncompleteCompletions (retrigger)
                            
                            // Calculate replacement range (standard Monaco pattern)
                            // This determines what text will be replaced when a suggestion is accepted
                            const word = model.getWordUntilPosition(position);
                            let range = {
                                startLineNumber: position.lineNumber,
                                endLineNumber: position.lineNumber,
                                startColumn: word.startColumn,
                                endColumn: word.endColumn
                            };
                            
                            // If triggered by a character, include it in the range
                            if (context.triggerKind === monaco.languages.CompletionTriggerKind.TriggerCharacter && context.triggerCharacter) {
                                // For trigger characters like '.', we want to replace from before the trigger
                                const lineContent = model.getLineContent(position.lineNumber);
                                const charBefore = lineContent.charAt(position.column - 2);
                                if (charBefore === context.triggerCharacter) {
                                    range.startColumn = Math.max(1, position.column - 1);
                                }
                            }
                            
                            // Get code up to and including the cursor position
                            // Match AvalonEdit behavior: editText.Text.Substring(0, editText.CaretOffset)
                            // Monaco's getValueInRange endColumn is EXCLUSIVE, so we need position.column + 1
                            // to include the character at the cursor position
                            // However, when triggered by '.', the cursor is AFTER the '.', so position.column
                            // already points past it, and getValueInRange with endColumn: position.column
                            // will include everything up to (but not including) position.column
                            // So we need to check: if we want to include the trigger character, we might need position.column
                            // But actually, if cursor is at column 13 after typing '.' at column 12,
                            // then getValueInRange(..., endColumn: 13) gets columns 1-12, which includes the '.'
                            
                            // To match AvalonEdit exactly: get all text from start to cursor position
                            // The cursor position in Monaco is 1-based, and endColumn is exclusive
                            // So to get text including the character BEFORE the cursor, we use position.column
                            // But to include the character AT the cursor (if any), we might need position.column + 1
                            
                            // Actually, let's be explicit: get everything from line 1, column 1, 
                            // up to and including the current line, up to the cursor column
                            let code = '';
                            for (let i = 1; i < position.lineNumber; i++) {
                                code += model.getLineContent(i) + '\n';
                            }
                            // For the current line, get up to the cursor position
                            const currentLine = model.getLineContent(position.lineNumber);
                            // position.column is 1-based, so substring(0, position.column - 1) gets chars 0 to position.column-2
                            // We want chars 0 to position.column-1 (inclusive), so use position.column
                            code += currentLine.substring(0, position.column - 1);
                            
                            // Debug logging
                            console.log('Monaco completion triggered:', {
                                line: position.lineNumber,
                                column: position.column,
                                triggerKind: context.triggerKind,
                                triggerCharacter: context.triggerCharacter,
                                codeLength: code.length,
                                codeEnd: code.substring(Math.max(0, code.length - 50)),
                                codePreview: code.substring(Math.max(0, code.length - 100))
                            });
                            
                            // Request completions from C#
                            const requestId = 'completion_' + Date.now() + '_' + Math.random();
                            pendingCompletions[requestId] = { resolve: resolve, range: range };
                            
                            // Set a timeout (standard practice for async providers)
                            setTimeout(function() {
                                if (pendingCompletions[requestId]) {
                                    console.log('Completion request timed out:', requestId);
                                    delete pendingCompletions[requestId];
                                    // Return empty suggestions on timeout (standard pattern)
                                    resolve({ suggestions: [] });
                                }
                            }, 5000);
                            
                            // Send completion request
                            if (window.chrome && window.chrome.webview) {
                                console.log('Sending completion request to C#:', {
                                    requestId: requestId,
                                    codeLength: code.length,
                                    codeEnd: code.substring(Math.max(0, code.length - 30)),
                                    line: position.lineNumber,
                                    column: position.column
                                });
                                
                                try {
                                    window.chrome.webview.postMessage({
                                        type: 'requestCompletions',
                                        requestId: requestId,
                                        code: code,
                                        line: position.lineNumber,
                                        column: position.column,
                                        triggerKind: context.triggerKind,
                                        triggerCharacter: context.triggerCharacter
                                    });
                                } catch (error) {
                                    console.error('Error sending completion request:', error);
                                    delete pendingCompletions[requestId];
                                    resolve({ suggestions: [] });
                                }
                            } else {
                                console.error('WebView not available - window.chrome.webview is null');
                                delete pendingCompletions[requestId];
                                resolve({ suggestions: [] });
                            }
                        });
                    },
                    // Optional: resolveCompletionItem - allows Monaco to request additional details on-demand
                    // This is more efficient than sending all documentation upfront
                    resolveCompletionItem: function(item, token) {
                        // If we already have documentation, return as-is
                        if (item.documentation && item.documentation.value) {
                            return Promise.resolve(item);
                        }
                        
                        // Otherwise, we could request additional details from C# here
                        // For now, return the item as-is (standard pattern when no additional resolution needed)
                        return Promise.resolve(item);
                    }
                });
                
                // 2. Hover Provider - Show documentation on hover
                monaco.languages.registerHoverProvider('python', {
                    provideHover: function(model, position) {
                        return new Promise(function(resolve) {
                            const word = model.getWordAtPosition(position);
                            if (!word) {
                                resolve(null);
                                return;
                            }
                            
                            // Get code up to cursor
                            const code = model.getValueInRange({
                                startLineNumber: 1,
                                startColumn: 1,
                                endLineNumber: position.lineNumber,
                                endColumn: position.column
                            });
                            
                            const requestId = 'hover_' + Date.now() + '_' + Math.random();
                            pendingHovers[requestId] = { resolve: resolve };
                            
                            setTimeout(function() {
                                if (pendingHovers[requestId]) {
                                    delete pendingHovers[requestId];
                                    resolve(null);
                                }
                            }, 3000);
                            
                            if (window.chrome && window.chrome.webview) {
                                window.chrome.webview.postMessage({
                                    type: 'requestHover',
                                    requestId: requestId,
                                    code: code,
                                    word: word.word,
                                    line: position.lineNumber,
                                    column: position.column
                                });
                            } else {
                                delete pendingHovers[requestId];
                                resolve(null);
                            }
                        });
                    }
                });
                
                // 3. Signature Help Provider - Show function signatures
                monaco.languages.registerSignatureHelpProvider('python', {
                    signatureHelpTriggerCharacters: ['(', ','],
                    signatureHelpRetriggerCharacters: [','],
                    provideSignatureHelp: function(model, position) {
                        return new Promise(function(resolve) {
                            // Get code up to cursor
                            const code = model.getValueInRange({
                                startLineNumber: 1,
                                startColumn: 1,
                                endLineNumber: position.lineNumber,
                                endColumn: position.column
                            });
                            
                            // Check if we're in a function call (have '(' before cursor)
                            const lineText = model.getLineContent(position.lineNumber);
                            const textBeforeCursor = lineText.substring(0, position.column - 1);
                            const lastOpenParen = textBeforeCursor.lastIndexOf('(');
                            
                            if (lastOpenParen === -1) {
                                resolve(null);
                                return;
                            }
                            
                            // Extract function name
                            const beforeParen = textBeforeCursor.substring(0, lastOpenParen).trim();
                            const match = beforeParen.match(/(\w+(?:\.\w+)*)$/);
                            if (!match) {
                                resolve(null);
                                return;
                            }
                            
                            const functionName = match[1];
                            const requestId = 'signature_' + Date.now() + '_' + Math.random();
                            pendingSignatures[requestId] = { resolve: resolve };
                            
                            setTimeout(function() {
                                if (pendingSignatures[requestId]) {
                                    delete pendingSignatures[requestId];
                                    resolve(null);
                                }
                            }, 3000);
                            
                            if (window.chrome && window.chrome.webview) {
                                window.chrome.webview.postMessage({
                                    type: 'requestSignature',
                                    requestId: requestId,
                                    code: code,
                                    functionName: functionName,
                                    line: position.lineNumber,
                                    column: position.column
                                });
                            } else {
                                delete pendingSignatures[requestId];
                                resolve(null);
                            }
                        });
                    }
                });
            })(); // Immediately invoke to register providers
            
            console.log('IntelliSense providers registered for Python');
            
            isInitialized = true;
            
            // Notify host that editor is ready
            if (window.chrome && window.chrome.webview) {
                window.chrome.webview.postMessage({
                    type: 'editorReady'
                });
            }
        });
        
        // API functions callable from C#
        window.monacoApi = {
            // Set editor content
            setContent: function(content) {
                if (editor) {
                    editor.setValue(content || '');
                }
            },
            
            // Get editor content
            getContent: function() {
                return editor ? editor.getValue() : '';
            },
            
            // Set language mode
            setLanguage: function(language) {
                if (editor) {
                    const mappedLanguage = languageMap[language.toLowerCase()] || language;
                    const previousLanguage = currentLanguage;
                    currentLanguage = mappedLanguage;
                    monaco.editor.setModelLanguage(editor.getModel(), mappedLanguage);
                    
                    // If switching to Python and providers weren't registered, register them now
                    if (mappedLanguage === 'python' && previousLanguage !== 'python') {
                        console.log('Language changed to Python, ensuring providers are registered');
                        // Providers are already registered globally, so they should work
                    }
                }
            },
            
            // Set read-only mode
            setReadOnly: function(readOnly) {
                if (editor) {
                    editor.updateOptions({ readOnly: readOnly });
                }
            },
            
            // Focus the editor
            focus: function() {
                if (editor) {
                    editor.focus();
                }
            },
            
            // Set font size
            setFontSize: function(size) {
                if (editor) {
                    editor.updateOptions({ fontSize: size });
                }
            },
            
            // Show/hide line numbers
            setLineNumbers: function(show) {
                if (editor) {
                    editor.updateOptions({ lineNumbers: show ? 'on' : 'off' });
                }
            },
            
            // Set word wrap
            setWordWrap: function(wrap) {
                if (editor) {
                    editor.updateOptions({ wordWrap: wrap ? 'on' : 'off' });
                }
            },
            
            // Set theme
            setTheme: function(theme) {
                if (editor) {
                    monaco.editor.setTheme(theme);
                }
            },
            
            // Insert text at cursor
            insertText: function(text) {
                if (editor) {
                    const selection = editor.getSelection();
                    const range = new monaco.Range(
                        selection.startLineNumber,
                        selection.startColumn,
                        selection.endLineNumber,
                        selection.endColumn
                    );
                    editor.executeEdits('', [{ range: range, text: text }]);
                }
            },
            
            // Register completion items provider (called from C#)
            registerCompletions: function(completions) {
                if (!editor) return;
                
                // completions is an array of { label, kind, insertText, detail, documentation }
                monaco.languages.registerCompletionItemProvider(currentLanguage, {
                    provideCompletionItems: function(model, position) {
                        const word = model.getWordUntilPosition(position);
                        const range = {
                            startLineNumber: position.lineNumber,
                            endLineNumber: position.lineNumber,
                            startColumn: word.startColumn,
                            endColumn: word.endColumn
                        };
                        
                        return {
                            suggestions: completions.map(function(c) {
                                return {
                                    label: c.label,
                                    kind: monaco.languages.CompletionItemKind[c.kind] || monaco.languages.CompletionItemKind.Text,
                                    insertText: c.insertText || c.label,
                                    detail: c.detail,
                                    documentation: c.documentation,
                                    range: range
                                };
                            })
                        };
                    }
                });
            },
            
            // Undo
            undo: function() {
                if (editor) {
                    editor.trigger('keyboard', 'undo', null);
                }
            },
            
            // Redo
            redo: function() {
                if (editor) {
                    editor.trigger('keyboard', 'redo', null);
                }
            },
            
            // Select all
            selectAll: function() {
                if (editor) {
                    editor.setSelection(editor.getModel().getFullModelRange());
                }
            },
            
            // Format document
            formatDocument: function() {
                if (editor) {
                    editor.getAction('editor.action.formatDocument').run();
                }
            },
            
            // Check if editor is ready
            isReady: function() {
                return isInitialized && editor !== null;
            }
        };
    </script>
</body>
</html>

